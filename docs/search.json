[
  {
    "objectID": "talks/index.html",
    "href": "talks/index.html",
    "title": "Conferences and Talks",
    "section": "",
    "text": "Lagrangian and Hamiltonian Graph Neural Networks for Robust Molecular Simulations\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nLagrangian and Hamiltonian Graph Neural Networks for Robust Molecular Simulations\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nUnderstanding the Compositional Control on Electrical, Mechanical, Optical, And Physical Properties of Inorganic Glasses with Interpretable Machine Learning\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nPeriDyn: A Peridynamics Package Written in Julia Programming Language\nRavinder Bhattoo*, N. M. Anoop Krishnan\n11th European Solid Mechanics Conference, July, 2022\nNUI, Galway, Ireland\nLearning Quantum-accuracy Interatomic Potential for Silica Using Lagrangian Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\n2022 Glass and Optical Materials Division Annual Meeting, May, 2022\nHyatt Regency Baltimore, Baltimore, MD, United States\nLearning interaction laws in atomistic system using Lagrangian Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\n2022 Glass and Optical Materials Division Annual Meeting, May, 2022\nHyatt Regency Baltimore, Baltimore, MD, United States\nDecoding the Genome of Inorganic Glasses using Interpretable Machine Learning\nRavinder Bhattoo*, N. M. Anoop Krishnan\n14th Pacific Rim Conference on Ceramic and Glass Technology and GOMD 2021 Division Meeting, December, 2021\nVancouver, British Columbia, Canada (Virtual)\nMolecular Dynamics Simulation Using Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\nMRS Fall Meeting 2021, December, 2021\nBoston, Massachusetts, USA (Virtual)\nUnderstanding the Composition-property Relationship of Glasses Using Interpretable Machine Learning\nRavinder Bhattoo*, Suresh Bishnoi, M. Zaki, N. M. Anoop Krishnan\nMaterials Science and Technology (MS&T) 2021, October, 2021\nColumbus, Ohio, USA (Virtual)\nMachine learning to predict the elastic properties of glasses\nSourabh Singh, Suresh Bishnoi, R. Ravinder*, Hariprasad Kodamana, N. M. Anoop Krishnan\nMaterial Science and Technology (MS&T) 2019, October, 2019\nOregon Convocation Center, Portland, USA"
  },
  {
    "objectID": "talks/index.html#talks",
    "href": "talks/index.html#talks",
    "title": "Conferences and Talks",
    "section": "",
    "text": "Lagrangian and Hamiltonian Graph Neural Networks for Robust Molecular Simulations\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nLagrangian and Hamiltonian Graph Neural Networks for Robust Molecular Simulations\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nUnderstanding the Compositional Control on Electrical, Mechanical, Optical, And Physical Properties of Inorganic Glasses with Interpretable Machine Learning\nRavinder Bhattoo*, N. M. Anoop Krishnan\nXXX International Materials Research Congress (IMRC2022) and International Conference on Advanced Materials (ICAM2021), August, 2022\nCancun, Mexico\nPeriDyn: A Peridynamics Package Written in Julia Programming Language\nRavinder Bhattoo*, N. M. Anoop Krishnan\n11th European Solid Mechanics Conference, July, 2022\nNUI, Galway, Ireland\nLearning Quantum-accuracy Interatomic Potential for Silica Using Lagrangian Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\n2022 Glass and Optical Materials Division Annual Meeting, May, 2022\nHyatt Regency Baltimore, Baltimore, MD, United States\nLearning interaction laws in atomistic system using Lagrangian Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\n2022 Glass and Optical Materials Division Annual Meeting, May, 2022\nHyatt Regency Baltimore, Baltimore, MD, United States\nDecoding the Genome of Inorganic Glasses using Interpretable Machine Learning\nRavinder Bhattoo*, N. M. Anoop Krishnan\n14th Pacific Rim Conference on Ceramic and Glass Technology and GOMD 2021 Division Meeting, December, 2021\nVancouver, British Columbia, Canada (Virtual)\nMolecular Dynamics Simulation Using Graph Neural Networks\nRavinder Bhattoo*, N. M. Anoop Krishnan\nMRS Fall Meeting 2021, December, 2021\nBoston, Massachusetts, USA (Virtual)\nUnderstanding the Composition-property Relationship of Glasses Using Interpretable Machine Learning\nRavinder Bhattoo*, Suresh Bishnoi, M. Zaki, N. M. Anoop Krishnan\nMaterials Science and Technology (MS&T) 2021, October, 2021\nColumbus, Ohio, USA (Virtual)\nMachine learning to predict the elastic properties of glasses\nSourabh Singh, Suresh Bishnoi, R. Ravinder*, Hariprasad Kodamana, N. M. Anoop Krishnan\nMaterial Science and Technology (MS&T) 2019, October, 2019\nOregon Convocation Center, Portland, USA"
  },
  {
    "objectID": "talks/index.html#workshops",
    "href": "talks/index.html#workshops",
    "title": "Conferences and Talks",
    "section": "Workshops",
    "text": "Workshops\n\nIntroduction to Machine Learning Tools\nArtificial Intelligence Concepts and Multidisciplinary Applications in Modern Biology, September, 2019\nInternational Center for Genetic Engineering and Biotechnology, New Delhi, India\nIntroduction to Machine Learning\nMachine Learning For Engineering Applications (TEQIP Course), June, 2019\nIndian Institute of Technology Delhi, New Delhi, India\nMolecular dynamics workshop 2\nAdvanced Simulation Methods: DFT, MD and Beyond, March, 2019\nIndian Institute of Technology Delhi, New Delhi, India"
  },
  {
    "objectID": "talks/index.html#posters",
    "href": "talks/index.html#posters",
    "title": "Conferences and Talks",
    "section": "Posters",
    "text": "Posters\n\nDesigning Functional Glasses using Machine Learning\nR. Ravinder*, Suresh Bishnoi, Sourabh Kumar Singh, Hargun Singh, Hariprasad Kodamana, N M Anoop Krishnan\nIIT Delhi Industry Day 2019, September, 2019\nIndian Institute of Technology Delhi, New Delhi, India\nTwo-dimensional glass transition in graphene: Insights from molecular simulations\nR. Ravinder*, Rajesh Kumar, Manish Agarwal, N. M. Anoop Krishnan\nAdvanced Simulation Methods: DFT, MD and Beyond, March, 2019\nIndian Institute of Technology Delhi, New Delhi, India"
  },
  {
    "objectID": "research/index.html",
    "href": "research/index.html",
    "title": "Research",
    "section": "",
    "text": "Title\nFunding source\nAmount\nDuration\n\n\n\n\nData-driven Structural Health Monitoring for Railway Truss Bridges\nDepartment of Science & Technology\n₹ 35 L\n2024-29"
  },
  {
    "objectID": "research/index.html#research-projects",
    "href": "research/index.html#research-projects",
    "title": "Research",
    "section": "",
    "text": "Title\nFunding source\nAmount\nDuration\n\n\n\n\nData-driven Structural Health Monitoring for Railway Truss Bridges\nDepartment of Science & Technology\n₹ 35 L\n2024-29"
  },
  {
    "objectID": "research/index.html#research",
    "href": "research/index.html#research",
    "title": "Research",
    "section": "Research",
    "text": "Research\n\nPhysics-informed Machine Learning\n\n\nStructural Health Monitoring\n\n\nPeridynamics\n\n\nTopology Optimization\n\n\nMolecular Dynamics"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ravinder Bhattoo",
    "section": "",
    "text": "Hi! I’m Ravinder Bhattoo, assistant professor in the Department of Civil Engineering at the Indian Institute of Technology Indore. My research focus areas are machine learning-aided structural design, multiscale material modeling, physics-informed machine learning, graph neural networks, dynamic fracture and crack propagation on ballistic impact, molecular dynamics, and peridynamics. Previously, I have worked as a postdoctoral scholar in the Department of Civil and Environmental Engineering at the University of Wisconsin-Madison and as an early doc scholar in the Department of Civil Engineering at the Indian Institute of Technology Delhi. I earned my Ph.D. in Civil Engineering from the Indian Institute of Technology Delhi in January 2023, and my B. Tech. in Civil Engineering from the Indian Institute of Technology Roorkee in June 2015. My Ph.D. research focused on data-driven modeling and physics-informed machine learning for glass discovery.\n\nRecent work\n\n\n\n\nPeriDyn is a numerical simulation software designed to solve peridynamics problems. It is written in the Julia programming language, and offers a high level of flexibility and speed. link"
  },
  {
    "objectID": "blogs/pdmaterialpoints/index.html",
    "href": "blogs/pdmaterialpoints/index.html",
    "title": "PDMaterialPoints",
    "section": "",
    "text": "Documentation\nPDMaterialPoints is a Julia package that can be used to generate particle-based objects for peridynamics simulations. Peridynamics is a relatively new computational framework for simulating the behavior of materials that takes into account long-range interactions between particles or points in a material, instead of the traditional continuum-based approach. PDMaterialPoints can be used to create particle-based objects, such as 2D and 3D meshes, that can be used as input for peridynamics simulations.\nIn this article, we will provide an overview of the types and methods available in the PDMaterialPoints package."
  },
  {
    "objectID": "blogs/pdmaterialpoints/index.html#types",
    "href": "blogs/pdmaterialpoints/index.html#types",
    "title": "PDMaterialPoints",
    "section": "Types",
    "text": "Types\nPDMaterialPoints provides several types for creating different shapes of particle-based objects:\n\nCone: A type representing a cone-shaped object with a given radius and length.\nCuboid: A type representing a cuboid-shaped object with given minimum and maximum bounds.\nCylinder: A type representing a cylinder-shaped object with a given radius, wall thickness, and length.\nDisk: A type representing a disk-shaped object with a given radius and thickness.\nPostOpObj: A type representing a post-operation object that is created lazily from another object and an operation to be applied.\nShape: An abstract type representing a generic shape object.\nSphere: A type representing a sphere-shaped object with a given radius."
  },
  {
    "objectID": "blogs/pdmaterialpoints/index.html#methods",
    "href": "blogs/pdmaterialpoints/index.html#methods",
    "title": "PDMaterialPoints",
    "section": "Methods",
    "text": "Methods\nPDMaterialPoints provides several methods for creating, manipulating, and deleting particle-based objects:\n\ncreate: An abstract method for creating a mesh object of a given shape with optional resolution, random perturbation, and particle type.\nchangetype: A method for changing the particle type of a mesh object using a boolean array generated from a given function.\ndelete: A method for deleting mesh particles of a mesh object using a boolean array generated from a given function.\nmove: A method for moving mesh particles of a mesh object by a given displacement.\nrotate: A method for rotating a shape object by a given angle about a given vector and point.\nvelocity: A method for changing the velocity of mesh particles of a mesh object using a boolean array generated from a given function and a given velocity.\n\nThe create method is an abstract method that generates a mesh object of a given shape. It can take optional parameters such as resolution, random perturbation, and particle type. The resolution parameter controls the number of particles in the mesh object. The random perturbation parameter can be used to introduce random noise into the mesh object, which can be useful for simulating realistic materials. The particle type parameter specifies the type of particle to use in the mesh object, which can be useful for simulating different types of materials.\nThe changetype method is used to change the type of particle in a mesh object. It takes a boolean array generated from a given function as input, which specifies the particles to be changed. The delete method is used to delete particles from a mesh object. It also takes a boolean array generated from a given function as input, which specifies the particles to be deleted.\nThe move method is used to move particles in a mesh object by a given displacement. It takes a mesh object and a displacement vector as input, and moves the particles in the mesh object by the given displacement vector. The rotate method is used to rotate a shape object by a given angle about a given vector and point. It takes a shape object, an angle, a vector, and a point as input, and rotates the shape object by the given angle about the given vector and point.\nThe velocity method is used to change the velocity of particles in a mesh object. It takes a boolean array generated from a given function as input, which specifies the particles to be changed.\nFinally, the delete method enables users to delete particles from an object using a boolean array from a specified function."
  },
  {
    "objectID": "blogs/pdmaterialpoints/index.html#examples-see-documentation-for-more-examples",
    "href": "blogs/pdmaterialpoints/index.html#examples-see-documentation-for-more-examples",
    "title": "PDMaterialPoints",
    "section": "Examples (see documentation for more examples)",
    "text": "Examples (see documentation for more examples)\nCreating a mesh for a composite material using PDMaterialPoints can be done by combining different shapes together. Here are some examples of composite material meshes that can be created using PDMaterialPoints:\n\nComposite material with randomly placed inclusions\n\nprintln(\"Creating a composite...\")\n\nusing PDMaterialPoints\n\nfunction rand_(a, b)\n    return a + rand()*(b-a)\nend\n\nobj = Cuboid([-10 10; -10 10; 0 3])\nfor i in 1:100\n    global obj\n    center = [rand_(-10, 10), rand_(-10, 10), rand_(0, 3)]\n    radius = 0.2 + 1.0*rand()\n    obj = changetype(obj, out -&gt; begin x=out[:x]; mask = sum((x .- vec(center)).^2, dims=1) .&lt; radius^2; mask .& (sum(out[:type][mask[1,:]] .== 2) == 0)  end, 2)\nend\n\nout = create(obj, resolution=0.1, rand_=0.0, type=1)\nwrite_data(\"./output/composite.data\", out)\n\n\n\ncomposite_block\n\n\n\nRotating composite strip\n\nprintln(\"Creating rotating strip...\")\n\nusing PDMaterialPoints\n\nc = Cuboid([-5 5; -10 10; 0 3])\nobj = copy(c)\n\nfor i in 1:100\n    global obj\n    obj = changetype(obj, out -&gt; begin x=out[:x]; sum(x[1:2, :].^2, dims=1) .&lt; 3.0^2 end, 2)\n    obj = changetype(obj, out -&gt; begin x=out[:x]; sum(x[1:2, :].^2, dims=1) .&lt; 2.0^2 end, 3)\n    obj = move(obj, by=[10.0, 0.0, 0.0])\n    obj = rotate(obj, angle=2, point=[0.0, 0.0, 0.0], vector_=[1.0, 1.0, 0.0])\n    obj = combine(obj, c)\nend\n\nout = create(obj, resolution=0.5, rand_=0.0, type=1)\nwrite_data(\"./output/strip.data\", out)\n\n\n\ncomposite_strip\n\n\nThe output files generated by PDMaterialPoints can be visualized using third-party software such as Ovito. PDMaterialPoints is a useful tool for researchers and scientists who are interested in studying the behavior of particles in various settings, such as materials science, fluid dynamics, and more.\nThe examples provided show how PDMaterialPoints can be used to create a range of particle configurations, from simple shapes such as spheres and cylinders to complex composite structures. The package also supports more advanced features such as rotation and movement of particles, which can be used to model dynamic systems.\nIn conclusion, the PDMaterialPoints package provides a set of powerful tools for generating particle-based objects for peridynamics simulations. Its various types and methods allow users to create a wide range of objects and manipulate them in various ways. Overall, the PDMaterialPoints package is a useful resource for researchers and engineers working in peridynamics and related fields."
  },
  {
    "objectID": "blogs/index.html",
    "href": "blogs/index.html",
    "title": "Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTitle\n\n\n\n\nReading Time\n\n\n\n\n\n\nPDMaterialPoints\n\n\n\n\n\n5 min\n\n\n\n\nPeriDyn: Peridynamics Package Written in Julia\n\n\n\n\n\n30 min\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blogs/peridyn/index.html",
    "href": "blogs/peridyn/index.html",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "",
    "text": "Documentation\nPeriDyn is a numerical simulation software designed to solve peridynamics problems. It is written in the Julia programming language, and offers a high level of flexibility and speed. PDBenchmark is built on top of the PeriDyn package, which provides a number of predefined material models and benchmark problems. This allows users to quickly set up and run simulations, and compare their results to established benchmarks.\nPeridynamics is a nonlocal continuum theory that can describe material failure and fracture without using the traditional concepts of stress and strain. Instead, it models a material as a collection of particles that interact through pairwise forces. These forces depend on the separation between particles, and can be used to simulate a wide range of materials, including brittle and ductile solids, fluids, and granular materials."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_env",
    "href": "blogs/peridyn/index.html#sec:chap7_env",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "PeriDyn Environment",
    "text": "PeriDyn Environment\nPeriDyn provide Env struct to hold information regarding system state and other parameters. Env struct is passed to the run! (see) function along with solver (see) and other simulation parameters such as number of time steps, file write frequency, and neighbor update interval etc. The Env struct is shown below.\nmutable struct GeneralEnv\n    id::Int64\n    type::AbstractArray{Int64,1}\n    bid::AbstractArray{Int64,1}\n    ghost_atoms::AbstractArray{Int64,1}\n    state::Int64\n    y::AbstractArray{Float64,2}\n    v::AbstractArray{Float64,2}\n    f::AbstractArray{Float64,2}\n    p::AbstractArray{Float64,2}\n    volume::AbstractArray{Float64,1}\n    intact0::AbstractArray{Int64, 1}\n    mass::AbstractArray{Float64,1}\n    time_step::Int64\n    dt::Float64\n    neighs::AbstractArray{Int64,2}\n    boundary_conditions::Any\n    short_range_repulsion::Any\n    material_blocks::Any\n    boundaries::Tuple\n    Collect!::Any\n    Params::Any\n    Out::Any\nend\nIt is a mutable struct type and can be updated once created. Instead of default constructor, PeriDyn also provide Env(id::Int64, materials, short_range_repulsion, boundary_conds, dt; state=2, bskin=0.5) where id is environment id, materials is array of material blocks (see) , short_range_repulsion is array of contact models (see) , boundary_conds is array of boundary conditions (see) , and dt is time step. It calculates all the filelds of Env struct under the hood and create an object of type Env. Once Env is created, it can be updated as and when required."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_dis",
    "href": "blogs/peridyn/index.html#sec:chap7_dis",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Material Discretization",
    "text": "Material Discretization\nPeridynamics utilize material point grid to define a material block. Each material point have its properties such as position, velocity, acceleration, volume and density etc. To define such properties of material block, PeriDyn provide GeneralMaterial(y0, v0, x, volume, type, horizon; max_neigh=100, particle_size=0) (see) where y0 is initial deformed position, v0 is initial velocity, x is reference position, volume is volume, type is type of material and horizon is horizon as defined in peridynamics. To discretize a material block, users can use PDMaterialPoints.jl (https://github.com/ravinderbhattoo/PDMaterialPoints.jl) which will provide y0, v0, x, volume, type for GeneralMaterial. Users can also use seperate software to generate files for these inputs and directly load these files in Julia."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_mat",
    "href": "blogs/peridyn/index.html#sec:chap7_mat",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Material Models",
    "text": "Material Models\nIn peridynamics, a material model defines the constitutive relationship of a material. These constitutive relationship dictates forces between material points on deformation. PeriDyn implements by holding information regarding material model with PeridynamicsMaterial(bid, gen, spc; name=\"PM\") struct, where bid is block id, gen is general material, spc is specific material, and name is name of peridynamics material block. The GeneralMaterial struct holds the information which are common for all the peridynamics material models where as SpecificMaterial holds the information which are specific to constitute relationship of material. The GeneralMaterial struct is given below.\nstruct GeneralMaterial\n    y::Array{Float64,2}\n    velocity::Array{Float64,2}\n    x::Array{Float64,2}\n    volume::Array{Float64,1}\n    type::Array{Int64,1}\n    particle_size::Float64\n    horizon::Float64\n    family::Array{Int64,2}\n    intact::BitArray{2}\n    weighted_volume::Array{Float64,1}\n    deformed::Vector{Bool}\nend\nPeriDyn also provide a GeneralMaterial(y0, v0, x, volume, type, horizon; max_neigh=100, particle_size=0) method which calculates some of the fields under the hood and return a object of type GeneralMaterial. An example of specific material model struct is given below.\nstruct BondBasedSpecific &lt;: SpecificMaterial\n    bond_stiffness::Array{Float64,2}\n    critical_stretch::Array{Float64, 2}\n    density::Array{Float64, 1}\nend\nHere, bond_stiffness is stiffness of bond as defined for micro-brittle-linear-elastic peridynamics material model, critical_stretch is critical stretch and density is density of material. BondBasedSpecific is a concrete subtype of SpecificMaterial which is an abstract type. A list of implemented SpecificMaterial is given below with their method signatures.\n\nBondBasedSpecific(S, critical_stretch, density::Array{Float64, 1})\nElastoPlasticSolidSpecific(bulk_modulus::Array{Float64,1}, shear_modulus::Array{Float64,1}, critical_stretch::Array{Float64,1}, density::Array{Float64,1}, sigma_y; criteria = VonMises())\nOrdinaryStateBasedSpecific(bulk_modulus::Array{Float64, 1}, shear_modulus::Array{Float64,1}, critical_stretch::Array{Float64,1}, density::Array{Float64,1})\nPairwiseNNSpecific(layers, critical_stretch, density::Array{Float64, 1}; act=Flux.relu)\nSkipSpecific()"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_contact",
    "href": "blogs/peridyn/index.html#sec:chap7_contact",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Contact Models",
    "text": "Contact Models\nIn peridynamics simulation, repulsive interaction between two physical blocks is modeled through a contact model. A contact model defines the repulsive interaction between particles of two physical blocks as well as the repulsive interaction between the particles of the same block which are not connected through peridynamics bond. To model such interactions, PeriDyn offers abstract type RepulsionModel11 and RepulsionModel12. Here, RepulsionModel11 model interaction between the particles of same block and RepulsionModel12 model interaction between the particles of different blocks. PeriDyn package implements the following contact models.\n\nLJRepulsionModel\nIt defines the LJ interactions between the particles of peridynamics material blocks using an expression \\(F(r) = \\frac{dV}{dr}\\) where \\(V(r) = 4\\epsilon((\\frac{\\sigma}{r})^{12} - (\\frac{\\sigma}{r})^6)\\).\nNonLinearRepulsionModel\nIt uses non-linear spring equation as \\(F(r) = K r^n\\) where \\(K\\) is spring constant and \\(n\\) is exponent.\nLinearRepulsionModel\nIt is a special case of NonLinearRepulsionModel where exponent is set to 1.\n\nAll contact models can be defined as ModelName(args..., mat1::PM, mat2::PM; distanceX = 5, max_neighs = 200) for inter-block interaction and ModelName(args..., mat1::PM; distanceX = 5, max_neighs = 200) for intra-block interactions. Here, the lookup distance (distanceX) for neighbors is set to a default value of 5 \\(\\times\\) the particle size and maximum number of neighbors max_neighs is set to a default value of 200.\nTo calculate the repulsive force using theses contact model, we use repulsion_force(dr, RepMod::RepulsionModel) where dr is distance between particles and RepMod is repulsion model defined for the particles.\nThe package also offers short_range_repulsion!(y, f, type, bid, vol, RM) which will mutate the force vector (f) of a given peridynamics environment by adding the repulsive forces. Here, y is updated position of particles, f is force vector, bid is block-id, vol is volume of particles and RM is repulsion model."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_bound",
    "href": "blogs/peridyn/index.html#sec:chap7_bound",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Boundary Conditions",
    "text": "Boundary Conditions\nTo impose external conditions such as constant strain rate, fix boundary, fixed force value and initial projectile velocity – the PeriDyn package use boundary conditions. Here, we define two abstract types BoundaryCondition and BoundaryConditionat0. The boundary condition BoundaryConditionat0 is applied only at start so that we can set some of the system values such as initial projectile velocity. The boundary condition BoundaryCondition is applied throughout the whole simulation. All the boundary conditions are concrete subtypes of one of the two abstract boundary conditions. To apply boundary condition during simulation, we use apply_bc!(env, BC::T, ::Type{Val{:position}}) where T &lt;: BoundaryCondition function inside a solver. The solver will apply all boundary conditions in order after each system state update. Note that since it is applied sequentially, a latter boundary condition can override a former boundary condition. A boundary condition is defined as a struct with at least the following fields.\nstruct BoundaryCondition\n    bool::Array{Bool, 1}\n    last::Array{Float64, 2}\n    onlyatstart::Bool\n    xF::Function\n    vF::Function\n    ...\nend\nHere, bool defines the boolean array for particle ids where the boundary condition will be applied. last is used to hold the previous state of the particles usually positions. onlyatstart is used for solvers which perform iterations other than the for time evolution. xF function is applied on positions and vF function is applied on velocities when boundary condition is applied. Some of the implemented boundary conditions are as follows:\n\nFixBC(bool; onlyatstart = false)\nFixBC will fix the particle positions from the initial frame. Here, only argument is a boolean array of particle ids and keyword argument is used as described above. It can be used to fix an end of a bar.\nToFroBC(bool, rate, freq; applyafter = 0, onlyatstart = false)\nGiven a velocity rate and frequency, ToFroBC will perform a to and fro motion for the particles. We can also delay the operation by setting applyafter to some desired frame. It can be used to apply a strain rate or constant velocity.\nMoveBC(bool, rate; kwargs...)\nMoveBC is a special case of to and fro boundary condition where the frequency is set to infinite explicitly by calling ToFroBC(bool, rate, Inf; kwargs...). Therefore, it will move the particles at a given rate in a particular direction.\nDeltaScaleBC(bool, scale, fixpoint; onlyatstart = false)\nDeltaScaleBC scales the material points about a fixed point. It can be used for quasi-static simulation where we look for the equilibrium position of the system. It is often easier to achieve equilibrium faster from a scaled system state."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_solver",
    "href": "blogs/peridyn/index.html#sec:chap7_solver",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Solvers",
    "text": "Solvers\nThe PeriDyn package provides two abstract type for solvers, a) QuasiStaticSolver for quasi-static simulations and b) DynamicSolver for dynamic simulations. It implements QSDrag(step_size, drag; max_iter = 100, x_tol = 1.0e-6, f_tol = 1.0e-6), here step_size is size of step in gradient descent optimiser and drag is for viscous damping, as a quasi-static solver which iteratively solves for position with equilibrium i.e. net force on all particles should be zero. All solvers &lt;: QuasiStaticSolver are suppose to have three parameters a) max_iter, the maximum number of iteration for finding solutuion for position, b) x_tol, the tolerance for change in position and c) f_tol, the tolerance for net force on particles. For dynamic simulation, PeriDyn provides DSVelocityVerlet() which perform standard velocity-verlet algorithm for time evolution of system. All dynamic solver implementations should be subtype of DynamicSolver and all quasi-static solver implementations should be subtype of QuasiStaticSolver. An apply_solver! function must be defined for all solvers (see) ."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_sim",
    "href": "blogs/peridyn/index.html#sec:chap7_sim",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Simulation",
    "text": "Simulation\nTo run a simulation with environments (see) , PeriDyn provide run! function. The run!(envs, N::Int64, solver; filewrite_freq::Int64 = 10,  neigh_update_freq::Int64 = 1, average_prop_freq::Int64 = 1, out_dir::String = \"datafile\", start_at::Int64 = 0, write_from::Int = 0, ext::Symbol = :jld, max_part = 30) function take, envs (array of environment), N (number of time steps), and solver (solver) as arguments with other keyword arguments. The function performs a loop with N time and updates the system state for all the environments. The run! function mutates the state of envs, and we get an array of updated environments. The simulate!(args...; out_dir=\"datafile\", append_date=true, kwargs...) function also provide similar functionality and it is wrapper over run! function. The run! function calls apply_solver!(apply_solver!(env, solver)) function where solver is a subtype of Union{QuasiStaticSolver, DynamicSolver}. Each solver must define apply_solver! function, which implements the solver over environment variables. The apply_solver! mutates the state of the given environment."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_para",
    "href": "blogs/peridyn/index.html#sec:chap7_para",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Parallel Computing",
    "text": "Parallel Computing\nIn peridynamics, for a given system state, the force calculation is per-particle basis and is independent of the forces on other particles. Therefore, parallel operations can be used to calculate the per-particle force. The force function force_density_T of material models uses map on the out loop and mapreduce on the inner loop during the force density calculation. The map and mapreduce are standard functions of Julia which perform operation in parallel. By default, Julia runs with four threads which can be override by executing julia -t num_threads for interactive session and julia -t num_threads filename.jl for running scripts. The PeriDyn package also uses Threads package for multi-threading of for loops in functions such as cal_family! (calculates the family members within the horizon), update_repulsive_neighs! (which updates the neighbors for the contact as defined in section (see) and weighted_volume. The performance of parallel operations for family calculation is shown in Figure 1 . The tests were performed with three systems with the number of particles 500000, 4000, and 500. As shown in Figure 1 a, b, c – the time taken to compute decreases with the number of threads available for parallel operations. We also plot the time taken vs the size of the system for four threads in Figure 1 . It show linear scaling for \\(log(T)\\) vs \\(log(N)\\) where \\(T\\) is the time and \\(N\\) is system size. The number shown in the figure may vary depending on the system hardware and other parameters.\n\n\n \n\n\nFigure 1: The performance of parallel operations for family calculation"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_io",
    "href": "blogs/peridyn/index.html#sec:chap7_io",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Input/Output",
    "text": "Input/Output\nThe package offers saving of file as text as well as binary using JLD julia package. The write_data(filename; kwargs...) functions is default function for writing simulation trajectories on the disk. It uses file extension as hint and fall back to an appropriate write function. It supports jld and data as valid file extensions. In case of an invalid file extensions, it defaults to jld data format without changing the given file extension. The solver function saves id, type, position, velocity, acceleration, mass, volume and damage to the disk using the write_data(filename; kwargs...) by providing keyword arguments. The default function to write jld files is save function from LJD julia package. It uses save(filename, items...) where items are the data-fields as provided in solver function. In case of data files, write_ovito(filename::String; kwargs...) is the default function which writes Ovito compatible text files according to its data file extension. It is advisable to write jld files during the simulation as writing jld file is much faster as compared to writing data file specially for larger file sizes. The package also provides functions to covert jld files to data files for visualization in Ovito 1.10 . The jld2ovito(filename::String) writes a new data file with data extensions appended to the given filename. To convert multiple jld files we can use jld2ovito(file, N; start = 0, step = 100) where file is string with a wildcard * for e.g. env_step_*.jld. The function will loop, with local variable i, from start to N with step step and replace the wildcard with i."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_vis",
    "href": "blogs/peridyn/index.html#sec:chap7_vis",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Visualization",
    "text": "Visualization\nVisualizing the simulation results of physical system is key to access the validity of the simulations. It also provides insights in the physical phenomenon happening during the simulation. As mentioned in the section (see), PeriDyn simulation files can be converted to Ovito compatible data files for visualization (see Figure 3). It is a text file with per particle information of the system. The write_ovito(filename::String; kwargs...) can be used to write files to insert custom data for visualization after preprocessing. The file structure for the data file is shown in Figure 2. Here, line number 1 show the total number of particles in the system, line number 2 show the column names for the data (note that some data column are grouped together under on name for e.g. position will have 3 columns), and remaining lines shows the data values.\n\n\n \n\n\nFigure 2: Data file in XYZ format.\n\n\n\n\n \n\n\nFigure 3: Visualization in Ovito."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_exam",
    "href": "blogs/peridyn/index.html#sec:chap7_exam",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Benchmarking PeriDyn models",
    "text": "Benchmarking PeriDyn models\nTo validate the existing models and PeriDyn, we perform test simulations for tensile loading (displacement controlled), flexure loading (displacement controlled), wave propagation (impulse load) and collision of separate material blocks. We compare simulation result with theoretical value qualitatively. Material block is also visualized at different stage of simulation."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_tensile",
    "href": "blogs/peridyn/index.html#sec:chap7_tensile",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Tensile simulation",
    "text": "Tensile simulation\nBar under tensile load (displacement controlled)\nA bar with length 7.2, cross-section 4\\(\\times\\)4 and resolution 0.1 is stretched using both ends of bar. The simulation is performed with a)BondBasedSpecificand b)OrdinaryStateBasedSpecific` material models as shown in Figure 5. Figure 4 shows the time evolution of damage. List of relevant parameters with arbitrary units are given in the table.\n\n\n\n\n\n\n\nParameter\nValue\n\n\n\n\nLength\n7.2\n\n\nWidth\n4.0\n\n\nHeight\n4.0\n\n\nResolution\n0.1\n\n\nPoison’s ratio\n0.25\n\n\nE (Young’s modulus)\n200.0\n\n\nK (bulk modulus)\n133.33\n\n\nG (shear modulus)\n80.0\n\n\nDensity\n2000.0\n\n\nCritical stretch\n0.01\n\n\nHorizon\n3\\(\\times\\)Resolution = 0.3\n\n\nTime step\n0.158\n\n\nBond stiffness\n\\(\\frac{18K}{\\pi \\times Horizon^4}\\) = 94314.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Bar showing evolution of damage during tensile load simulation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Normal stress vs strain curve for bar simulation under constant strain rete for a) bond based model and b) ordinary state based model.\n\n\nAs shown in Figure 5, the Young’s modulus from simulation is close to the given Young’s modulus.\n\n\n\nMaterial model\nActual\nSimulation\n\n\n\n\nBondBasedSpecific\n200.0\n190.1\n\n\nOrdinaryStateBasedSpecific\n200.0\n210.5"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_flexure",
    "href": "blogs/peridyn/index.html#sec:chap7_flexure",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Flexure simulation",
    "text": "Flexure simulation\nBar under flexure loading (displacement controlled)\nA bar with length 12.4, cross-section 2.0$$2.0 and resolution 0.2 is fixed at both ends and both ends are moved in lateral direction to induce flexure load. The simulation is performed with BondBasedSpecific material model as shown in Figure 7. Figure 6 shows the time evolution of damage. List of relevant parameters with arbitrary units are given in Table [tab:chap7_exam_fle].\n\n\n\nParameter\nValue\n\n\n\n\nLength\n12.4\n\n\nWidth\n2.0\n\n\nHeight\n2.0\n\n\nResolution\n0.2\n\n\nPoison’s ratio\n0.25\n\n\nE (Young’s modulus)\n200.0\n\n\nK (bulk modulus)\n133.33\n\n\nG (shear modulus)\n80.0\n\n\nDensity\n2000.0\n\n\nCritical stretch\n0.01\n\n\nHorizon\n3\\(\\times\\)Resolution = 0.6\n\n\nTime step\n0.632\n\n\nBond stiffness\n\\(\\frac{18K}{\\pi \\times Horizon^4}\\) = 5894.6\n\n\nFlexure stiffness\n\\(\\frac{12EI}{L^4}\\) = 1.67\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Damage evolution of a bar under flexure load.\n\n\n\n\n\nFigure 7: Lateral force vs displacement curve for bar under flexure load.\n\n\nAs shown in Figure 7, the flexural stiffness from simulation is close to the calculated theoretical value.\n\n\n\nMaterial model\nActual\nSimulation\n\n\n\n\nBondBasedSpecific\n1.67\n1.78"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:chap7_impact",
    "href": "blogs/peridyn/index.html#sec:chap7_impact",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Impact simulation",
    "text": "Impact simulation\nImpact (collision of separate blocks)\nA disk with radius 25.0, thickness 4.0 and resolution 0.5 is is hit by a projectile. The simulation is performed with BondBasedSpecific material model as shown in Figure 11. Figure 10 shows the time evolution of damage. List of relevant parameters with arbitrary units are given in the table.\n\n\n\n\n\n\n\nParameter\nValue\n\n\n\n\nDisk radius\n25.0\n\n\nDisk thickness\n4.0\n\n\nDisk resolution\n0.5\n\n\nProjectile radius\n3.0\n\n\nProjectile resolution\n0.5\n\n\nPoison’s ratio\n0.25\n\n\nE (Young’s modulus)\n2000.0\n\n\nK (bulk modulus)\n1333.3\n\n\nG (shear modulus)\n800.0\n\n\nDisk density\n2000.0\n\n\nProjectile density\n20000.0\n\n\nDisk critical stretch\n0.01\n\n\nProjectile critical stretch\n0.1\n\n\nHorizon\n3\\(\\times\\)Resolution = 1.5\n\n\nTime step\n0.5\n\n\nBond stiffness\n\\(\\frac{18K}{\\pi \\times Horizon^4}\\) = 1509.0\n\n\n\nTable: Parameters for simulating an impact of a projectile on a disk.\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\n\n\nBack\n\n\n\n\n\nFront\n\n\n\nFigure 10: Damage evolution of a disk being hit by a projectile.\n\n\n\n\n\nFigure 11: Damage evolution of a disk being hit by a projectile."
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:mlpd",
    "href": "blogs/peridyn/index.html#sec:mlpd",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Machine learned constitutive relationship",
    "text": "Machine learned constitutive relationship"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:mlpd_bb",
    "href": "blogs/peridyn/index.html#sec:mlpd_bb",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Peridynamics simulation with bond based material",
    "text": "Peridynamics simulation with bond based material\n  # Tensile simulation\n  # importing packages\n  using PDBenchmark\n  using PeriDyn\n  using Random\n  using BSON\n  using Flux\n  Random.seed!(42)\n  # setting paramters\n  const Es = 70.0\n  const nu = 0.25 # for bond based peridynamics\n  K = Es/3/(1-2nu)\n  G = Es/2/(1+nu)\n  const rho = 2.2 # g/cm3\n  wv = sqrt(Es/rho)\n  println(\"Wave velocity: \", wv)\n  const cs = 0.1\n  const reso = 0.1\n  const horizon = 3.0*reso\n  time_step = 0.5 * reso / wv\n  C = 18K/(pi*horizon^4)\n  # define material block\n  gen_mat = PDBenchmark.NameParam(:GeneralMaterial, (horizon), Dict(:max_neigh=&gt;150, :skip_bb=&gt;true))\n  spc_mat = PDBenchmark.NameParam(:BondBasedSpecific, ([C], [cs], [rho], ), Dict(:func=&gt;(s, C) -&gt; C*s))\n  # define solver\n  solver = DSVelocityVerlet()\n  # setup and clean output directory\n  out_dir = \"MLTensileBarBBNL_\" * string(typeof(solver))\n  try\n      foreach(rm, filter(endswith(\".data\"), readdir(\"./output/\"*out_dir, join=true)))\n  catch\n      nothing\n  end\n  # perform simulation\n  test = PDBenchmark.TensileBar(;gen_mat=gen_mat, dt=time_step,\n                                  spc_mat=spc_mat, resolution=reso, solver=solver, Steps=1000, out_dir=out_dir, fwf=10, makeplot=true, trueE=Es)\n  env, solver, solvef! = PDBenchmark.stage!(test)\n  solvef!(env, solver)"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:mlpd_ml",
    "href": "blogs/peridyn/index.html#sec:mlpd_ml",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Machine leanring with PeriDyn",
    "text": "Machine leanring with PeriDyn\n# importing packages\nusing PeriDyn\nusing Random\nusing Flux\nusing BSON\nusing Zygote\nusing PDMaterialPoints\nRandom.seed!(2020)\n# adding some zygote rules (not necessary for the task every time)\nusing Zygote\nfunction add!(a::Nothing, b::Zygote.Grads)\n    b\nend\nfunction add!(a::Zygote.Grads, b::Zygote.Grads)\n    for p in a.params\n        a[p] .= a[p] .+ b[p]\n    end\n    a\nend\nfunction div!(a::Zygote.Grads, i::T) where T &lt;: Real\n    for p in a.params\n        a[p] ./= i\n    end\n    a\nend\nfunction mul!(a::Zygote.Grads, i::T) where T &lt;: Real\n    for p in a.params\n        a[p] .*= i\n    end\n    a\nend\n# parameters for simulation\nconst Es = 70.0\nconst nu = 0.25 # for bond based peridynamics\nK = Es/3/(1-2nu)\nG = Es/2/(1+nu)\nconst rho = 2.2 # g/cm3\nwv = sqrt(Es/rho)\nprintln(\"Wave velocity: \", wv)\nconst cs = 0.1\nconst reso = 0.1\nconst horizon = 3.0*reso\ntime_step = 0.5 * reso / wv\nC = 18K/(pi*horizon^4)\n# read data from simulation\nOut = PeriDyn.jld2array(\"./output/$(out_dir)/env_1_step_*.jld\", 1000; start=0, step=10)\n\n# defien material models\nx = Out[1][:position]\nvol = Out[1][:volume]\ntype = Out[1][:type]\nout = x, 0*x, x, vol, type\ngen_mat = GeneralMaterial(out..., horizon; max_neigh=150, skip_bb=true)\nsquareplus(x) = 0.5*(x + sqrt(x^2 + 4))\nnn_spc_mat = PairwiseNNSpecific([1, 10, 10, 1], [cs], [rho]; act=squareplus)\nnn_mat = PeridynamicsMaterial(deepcopy(gen_mat), nn_spc_mat)\n# edit default NN model\nmodel = Chain(Dense(1, 10, leakyrelu), Dense(10, 10, leakyrelu), Dense(10, 1, leakyrelu), x-&gt;1000*x)\nnn_mat.specific.NNs[1, 1] = model\n# loss function\nfunction loss(kk)\n    Ns = Zygote.@ignore get_Ns()\n    data = Out[kk][:acceleration] ./ density\n    sum((data - force_density_T(Out[kk][:position], nn_mat; particles=Ns)).^2)\nend\n# optimiser\nps = Flux.params(nn_mat.specific.NNs[1, 1])\nopt = Flux.Adam()\nNs = [1]\nfunction get_Ns()\n    Ns\nend\n# Training\nfor i in 1:10000\n    if (i%10==0 | i==1)\n        Ns = rand(1:size(y, 2), 10)\n        nns = rand(1:100, 2)\n    end\n    gs = div!(reduce(add!, ((kk) -&gt; Flux.gradient(()-&gt;loss(kk), ps)).(nns)), length(nns))\n    Flux.update!(opt, ps, gs)\n    println(\"$i, $(reduce(+, loss.(nns))/length(nns))\")\n    # save model every 100 iteration\n    if i%100==0\n        BSON.@save \"mymodel.bson\" model\n    end\nend"
  },
  {
    "objectID": "blogs/peridyn/index.html#sec:mlpd_nn",
    "href": "blogs/peridyn/index.html#sec:mlpd_nn",
    "title": "PeriDyn: Peridynamics Package Written in Julia",
    "section": "Peridynamics simulation with machine learned material",
    "text": "Peridynamics simulation with machine learned material\n# Tensile simulation with machine learned material\n# importing packages\nusing PDBenchmark\nusing PeriDyn\nusing Random\nusing BSON\nusing Flux\nRandom.seed!(42)\n# setting paramters\nconst Es = 70.0\nconst nu = 0.25 # for bond based peridynamics\nK = Es/3/(1-2nu)\nG = Es/2/(1+nu)\nconst rho = 2.2 # g/cm3\nwv = sqrt(Es/rho)\nprintln(\"Wave velocity: \", wv)\nconst cs = 0.1\nconst reso = 0.1\nconst horizon = 3.0*reso\ntime_step = 0.5 * reso / wv\nC = 18K/(pi*horizon^4)\n# define material block\ngen_mat = PDBenchmark.NameParam(:GeneralMaterial, (horizon), Dict(:max_neigh=&gt;150, :skip_bb=&gt;true))\nsquareplus(x) = 0.5*(x + sqrt(x^2 + 4))\nspc_mat = PDBenchmark.NameParam(:PairwiseNNSpecific, ([1, 10, 10, 1], [cs], [rho]), Dict(:act=&gt;squareplus))\n# define solver\nsolver = DSVelocityVerlet()\n# setup and clean output directory\nout_dir = \"MLTensileBarBBNL_\" * string(typeof(solver))\ntry\n    foreach(rm, filter(endswith(\".data\"), readdir(\"./output/\"*out_dir, join=true)))\ncatch\n    nothing\nend\n# perform simulation\ntest = PDBenchmark.TensileBar(;gen_mat=gen_mat, dt=time_step,\n                                spc_mat=spc_mat, resolution=reso, solver=solver, Steps=1000, out_dir=out_dir, fwf=10, makeplot=true, trueE=Es)\nenv, solver, solvef! = PDBenchmark.stage!(test)\nBSON.@load \"mymodel.bson\" model\nenv.material_blocks[1].specific.NNs[1, 1] = model\nsolvef!(env, solver)"
  },
  {
    "objectID": "publications/index.html",
    "href": "publications/index.html",
    "title": "Publications",
    "section": "",
    "text": "Our paper on 21 challenges in AI and ML in glass technology featured in American Ceramic Society’s CTT. Read the article here. A reprint of the article can be found in Glass machinery plants and accessories magazine here\nOur paper on glassy h-BN selected as the cover page in Advanced Theory and Simulations. Read the paper here\nYou can also find my articles on Google Scholar profile."
  },
  {
    "objectID": "publications/index.html#journal-articles",
    "href": "publications/index.html#journal-articles",
    "title": "Publications",
    "section": "Journal Articles",
    "text": "Journal Articles\n\nUnderstanding the compositional control on electrical, mechanical, optical, and physical properties of inorganic glasses with interpretable machine learning\nBhattoo, Ravinder; Bishnoi, Suresh; Zaki, Mohd; Krishnan, N. M. Anoop;\nActa Materialia, 2023. doi: 10.1016/j.actamat.2022.118439\nLearning the dynamics of particle-based systems with Lagrangian graph neural networks\nBhattoo, Ravinder; Ranu, Sayan; Krishnan, N. M. Anoop;\nMachine Learning: Science and Technology, 2023. doi: 10.1088/2632-2153/acb03e\nInterpreting the optical properties of oxide glasses with machine learning and Shapely additive explanations\nZaki, Mohd; Venugopal, Vineeth; Bhattoo, Ravinder; Bishnoi, Suresh; Singh, Sourabh Kumar; Allu, Amarnath R.; Jayadeva; Krishnan, N. M. Anoop;\nJournal of the American Ceramic Society, 2022. doi: 10.1111/jace.18345\nScalable Gaussian processes for predicting the optical, physical, thermal, and mechanical properties of inorganic glasses with large datasets\nBishnoi, Suresh; Ravinder, R.; Grover, Hargun Singh; Kodamana, Hariprasad; Krishnan, N. M. Anoop\nMaterials Advances, 2021. doi: 10.1039/D0MA00764A\nArtificial intelligence and machine learning in glass science and technology: 21 challenges for the 21st century\nRavinder; Venugopal, Vineeth; Bishnoi, Suresh; Singh, Sourabh; Zaki, Mohd; Grover, Hargun Singh; Bauchy, Mathieu; Agarwal, Manish; Krishnan, N. M. Anoop\nInternational Journal of Applied Glass Science, 2021. doi: 10.1111/ijag.15881\nIrradiation-induced brittle-to-ductile transition in α-quartz\nRavinder, R.; Kumar, Abhishek; Kumar, Rajesh; Vangla, Prashanth; Krishnan, N. M. Anoop\nJournal of the American Ceramic Society, 2020. doi: 10.1111/jace.16951\nGlass Transition and Crystallization in Hexagonal Boron Nitride: Crucial Role of Orientational Order\nRavinder, R.; Garg, Prateet; Krishnan, N. M. Anoop\nAdvanced Theory and Simulations, 2020. doi: 10.1002/adts.201900174\nDeep learning aided rational design of oxide glasses\nRavinder, R.; Sridhara, Karthikeya H.; Bishnoi, Suresh; Grover, Hargun Singh; Bauchy, Mathieu; Jayadeva; Kodamana, Hariprasad; Krishnan, N. M. Anoop\nMaterials Horizons, 2020. doi: 10.1039/D0MH00162G\nCooling rate effects on the structure of 45S5 bioglass: Insights from experiments and simulations\nBhaskar, Pratik; Kumar, Rajesh; Maurya, Yashasvi; Ravinder, R.; Allu, Amarnath R.; Das, Sumanta; Gosvami, Nitya Nand; Youngman, Randall E.; Bødker, Mikkel S.; Mascaraque, Nerea; Smedskjaer, Morten M.; Bauchy, Mathieu; Krishnan, N. M. Anoop\nJournal of Non-Crystalline Solids, 2020. doi: 10.1016/j.jnoncrysol.2020.119952\nAn adaptive, interacting, cluster-based model for predicting the transmission dynamics of COVID-19\nRavinder, R.; Singh, Sourabh; Bishnoi, Suresh; Jan, Amreen; Sharma, Amit; Kodamana, Hariprasad; Krishnan, N. M. Anoop\nHeliyon, 2020. doi: 10.1016/j.heliyon.2020.e05722\nA Peridynamics-Based Micromechanical Modeling Approach for Random Heterogeneous Structural Materials\nNayak, Sumeru; Ravinder, R.; Krishnan, N. M. Anoop; Das, Sumanta\nMaterials, 2020. doi: 10.3390/ma13061298\nRedox Sensitive Self-Assembling Dipeptide for Sustained Intracellular Drug Delivery\nDhawan, Sameer; Ghosh, Sukanya; Ravinder, R.; Bais, Sachendra S.; Basak, Soumen; Krishnan, N. M. Anoop; Agarwal, Manish; Banerjee, Manidipa; Haridas, V.\nBioconjugate Chemistry, 2019. doi: 10.1021/acs.bioconjchem.9b00532\nPredicting Young’s modulus of oxide glasses with sparse datasets using machine learning\nBishnoi, Suresh; Singh, Sourabh; Ravinder, R.; Bauchy, Mathieu; Gosvami, Nitya Nand; Kodamana, Hariprasad; Krishnan, N. M. Anoop\nJournal of Non-Crystalline Solids, 2019. doi: 10.1016/j.jnoncrysol.2019.119643\nGlass Fracture Upon Ballistic Impact: New Insights From Peridynamics Simulations\nRivera, Jared; Berjikian, Jonathan; Ravinder, R.; Kodamana, Hariprasad; Das, Sumanta; Bhatnagar, Naresh; Bauchy, Mathieu; Krishnan, N. M. Anoop\nFrontiers in Materials, 2019. doi: 10.3389/fmats.2019.00239\nEvidence of a two-dimensional glass transition in graphene: Insights from molecular simulations\nRavinder, R.; Kumar, Rajesh; Agarwal, Manish; Krishnan, N. M. Anoop\nScientific Reports, 2019. doi: 10.1038/s41598-019-41231-z\nDensity–stiffness scaling in minerals upon disordering: Irradiation vs. vitrification\nKrishnan, N. M. Anoop; Ravinder, R.; Kumar, Rajesh; Le Pape, Yann; Sant, Gaurav; Bauchy, Mathieu\nActa Materialia, 2019. doi: 10.1016/j.actamat.2019.01.015"
  },
  {
    "objectID": "publications/index.html#preprints",
    "href": "publications/index.html#preprints",
    "title": "Publications",
    "section": "Preprints",
    "text": "Preprints\n\nLagrangian Neural Network with Differentiable Symmetries and Relational Inductive Bias\nBhattoo, Ravinder; Ranu, Sayan; Krishnan, N. M. Anoop\nPreprint, 2021. url: http://arxiv.org/abs/2110.03266"
  },
  {
    "objectID": "publications/index.html#conference-papers",
    "href": "publications/index.html#conference-papers",
    "title": "Publications",
    "section": "Conference Papers",
    "text": "Conference Papers\n\nLearning the Dynamics of Physical Systems with Hamiltonian Graph Neural Networks\nBishnoi, Suresh; Bhattoo, Ravinder; Jayadeva, Jayadeva; Ranu, Sayan; Krishnan, N. M. Anoop\nICLR 2023 Workshop on Physics for Machine Learning, 2023. url: https://openreview.net/forum?id=Ugl-B_at5n\nEnhancing the Inductive Biases of Graph Neural ODE for Modeling Physical Systems\nBishnoi, Suresh; Bhattoo, Ravinder; Jayadeva, Jayadeva; Ranu, Sayan; Krishnan, N. M. Anoop\nThe Eleventh International Conference on Learning Representations, 2023. url: https://openreview.net/forum?id=ATLEl_izD87\nUnravelling the Performance of Physics-informed Graph Neural Networks for Dynamical Systems\nThangamuthu, Abishek; Kumar, Gunjan; Bishnoi, Suresh; Bhattoo, Ravinder; Krishnan, N. M. Anoop; Ranu, Sayan\nThirty-sixth Conference on Neural Information Processing Systems Datasets and Benchmarks Track, 2022. url: https://openreview.net/forum?id=tXEe-Ew_ikh\nLearning Articulated Rigid Body Dynamics with Lagrangian Graph Neural Network\nBhattoo, Ravinder; Ranu, Sayan; Krishnan, N. M. Anoop\nAdvances in Neural Information Processing Systems, 2022. url: https://openreview.net/forum?id=nOdfIbo3A-F"
  },
  {
    "objectID": "resources/softwares.html",
    "href": "resources/softwares.html",
    "title": "Softwares",
    "section": "",
    "text": "PeriDyn [github] [Docs]\nPDMaterialPoints [github] [Docs]\nPDBenchmark [github] [Docs]"
  },
  {
    "objectID": "resources/softwares.html#peridynamics",
    "href": "resources/softwares.html#peridynamics",
    "title": "Softwares",
    "section": "",
    "text": "PeriDyn [github] [Docs]\nPDMaterialPoints [github] [Docs]\nPDBenchmark [github] [Docs]"
  },
  {
    "objectID": "resources/softwares.html#molecular-dynamics",
    "href": "resources/softwares.html#molecular-dynamics",
    "title": "Softwares",
    "section": "Molecular Dynamics",
    "text": "Molecular Dynamics\n\nMDSimulator.jl [github]\nMDBase.jl [github]"
  },
  {
    "objectID": "resources/softwares.html#miscellaneous",
    "href": "resources/softwares.html#miscellaneous",
    "title": "Softwares",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\nGlassConversionPy [github]\nMLPipeline [github]\nMixModelsPytorch [github]\nkurma [github]"
  }
]